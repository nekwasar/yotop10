# M3 ‚Äî Authentication System

> **Goal**: Users can create accounts, log in with email or Google, reset passwords, and start anonymous sessions. By the end of M3, a real user can sign up on `https://yotop10.com`, verify their email, log in, and stay logged in across browser sessions. JWTs handle sessions on the backend; NextAuth handles sessions on the frontend.

---

## Architecture Overview

```
Browser (Next.js)
‚îÇ
‚îú‚îÄ‚îÄ /signup           ‚Üí calls POST /api/auth/register
‚îú‚îÄ‚îÄ /login            ‚Üí calls POST /api/auth/login  OR  Google OAuth flow
‚îú‚îÄ‚îÄ /verify-email     ‚Üí calls POST /api/auth/verify-email
‚îú‚îÄ‚îÄ /forgot-password  ‚Üí calls POST /api/auth/forgot-password
‚îî‚îÄ‚îÄ /reset-password   ‚Üí calls POST /api/auth/reset-password

NextAuth (frontend session layer)
‚îÇ
‚îî‚îÄ‚îÄ stores JWT in httpOnly cookie ‚Üí all protected pages read it

FastAPI Backend
‚îÇ
‚îú‚îÄ‚îÄ Issues JWTs (access token 30 days, refresh token 90 days)
‚îú‚îÄ‚îÄ Sends verification + reset emails via Brevo
‚îú‚îÄ‚îÄ Handles Google OAuth callback
‚îî‚îÄ‚îÄ Stores hashed passwords in PostgreSQL
```

**Key decisions:**
- Passwords are hashed with **bcrypt** ‚Äî never stored plain
- Emails are **verified before full account access** ‚Äî single use token, 24hr expiry
- Google OAuth users have **no password** ‚Äî they log in via Google only
- Anonymous users get a **device-fingerprinted guest session** ‚Äî limited until they register
- JWT access tokens live **30 days**; if expired, the refresh token silently renews them

---

## Prerequisites

- M1 complete (FastAPI running, Docker up, CI/CD green) ‚úÖ
- M2 complete (database tables created via Alembic) ‚úÖ
- Brevo account with API key and domain verified
- Google OAuth credentials (Client ID + Client Secret) already in `.env` ‚úÖ

---

## Step 1 ‚Äî üíª LOCAL: Install New Backend Dependencies

Add the auth-related packages to `backend/requirements.txt`:

```
python-jose[cryptography]==3.3.0   ‚Üê already there (JWT)
passlib[bcrypt]==1.7.4             ‚Üê already there (password hashing)
python-multipart==0.0.12           ‚Üê already there (form data)
httpx==0.27.2                      ‚Üê already there (Google OAuth)
```

No new packages needed ‚Äî everything for auth is already in requirements.txt from M1.

> **Why these?** `python-jose` creates and validates JWTs. `passlib[bcrypt]` hashes passwords. `httpx` calls Google's OAuth API to verify the token from the frontend.

---

## Step 2 ‚Äî üíª LOCAL: Create the Auth Module Structure

Inside `backend/app/`, create these new files:

```
backend/app/
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ v1/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.py           ‚Üê all auth endpoints live here
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ security.py           ‚Üê JWT creation, password hashing
‚îÇ   ‚îî‚îÄ‚îÄ email.py              ‚Üê Brevo email sender
‚îú‚îÄ‚îÄ schemas/
‚îÇ   ‚îî‚îÄ‚îÄ auth.py               ‚Üê Pydantic request/response models
‚îú‚îÄ‚îÄ crud/
‚îÇ   ‚îî‚îÄ‚îÄ user.py               ‚Üê database operations for users
‚îî‚îÄ‚îÄ services/
    ‚îî‚îÄ‚îÄ auth.py               ‚Üê business logic (register, login, OAuth)
```

> **Why separate layers?** Each file has one job. The endpoint (api/v1/auth.py) only handles HTTP ‚Äî it validates input and calls the service. The service (services/auth.py) has the actual logic. The CRUD layer (crud/user.py) only talks to the database. This separation means you can change the database or the email provider without touching the API layer.

---

## Step 3 ‚Äî üíª LOCAL: Build the Security Utilities

**`backend/app/core/security.py`** handles three things:

### Password Hashing
Uses bcrypt to hash passwords before storing them, and verify them at login:
```python
# Never store raw passwords ‚Äî always hash first
hashed = hash_password("user_password")
is_valid = verify_password("user_password", hashed)  # True
```

### JWT Creation
Creates two token types:
- **Access token** (30 days) ‚Äî sent with every API request in the Authorization header
- **Refresh token** (90 days) ‚Äî only sent when access token expires, used to get a new one

```python
# Access token: {"sub": "user_id_123", "exp": <30 days from now>}
access_token = create_access_token(data={"sub": str(user.id)})
```

### Token Verification
FastAPI dependency that protects endpoints ‚Äî extracts the user from the JWT:
```python
# Any endpoint can require auth by adding: current_user = Depends(get_current_user)
async def get_current_user(token: str) ‚Üí User:
    payload = decode_token(token)
    return db.get_user(payload["sub"])
```

---

## Step 4 ‚Äî üíª LOCAL: Build the Email Service

**`backend/app/core/email.py`** uses the Brevo API to send two types of emails:

### Verification Email
Sent immediately after signup. Contains a link:
```
https://yotop10.com/verify-email?token=<24hr_single_use_token>
```
- Token is stored in the `users` table (`email_verify_token` column)
- When the user clicks the link ‚Üí the frontend calls `POST /api/auth/verify-email`
- Backend checks: token exists, not expired, matches user ‚Üí sets `is_verified = True`

### Password Reset Email
Sent when user requests a reset. Contains:
```
https://yotop10.com/reset-password?token=<1hr_single_use_token>
```
- Token stored in `users.reset_password_token`
- User submits new password ‚Üí backend verifies token ‚Üí updates hash ‚Üí clears token

> **Why Brevo over SMTP?** Brevo's API is more reliable than raw SMTP and the free tier covers everything for early launch. If Brevo is down, just swap the sending function ‚Äî the rest of the code doesn't change.

---

## Step 5 ‚Äî üíª LOCAL: Build the User CRUD Layer

**`backend/app/crud/user.py`** ‚Äî all database reads/writes for users:

| Function | What it does |
|---|---|
| `get_user_by_email(db, email)` | Look up user by email (for login) |
| `get_user_by_id(db, user_id)` | Look up user by ID (for JWT auth) |
| `create_user(db, data)` | Insert new user row with hashed password |
| `update_user(db, user, data)` | Update user fields |
| `set_verified(db, user)` | Mark email as verified |
| `set_reset_token(db, user, token)` | Store password reset token |
| `clear_reset_token(db, user)` | Clear token after use |

> These are purely database functions ‚Äî no business logic, no HTTP. This makes them easy to test in isolation.

---

## Step 6 ‚Äî üíª LOCAL: Build the Pydantic Schemas

**`backend/app/schemas/auth.py`** ‚Äî defines the shape of every request and response body:

### Request schemas (what the client sends):
```python
class RegisterRequest:
    email: str          # validated as email format
    password: str       # min 8 chars
    username: str       # 3-20 chars, alphanumeric + underscores only
    display_name: str   # 1-50 chars

class LoginRequest:
    email: str
    password: str

class ForgotPasswordRequest:
    email: str

class ResetPasswordRequest:
    token: str
    new_password: str   # min 8 chars
```

### Response schemas (what the API returns):
```python
class AuthResponse:
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    user: UserPublic    # user's public info

class UserPublic:
    id: UUID
    username: str
    display_name: str
    avatar_url: str | None
    is_verified: bool
```

> Pydantic schemas automatically validate incoming data and serialize outgoing data. If a request is missing a required field, FastAPI returns a 422 error automatically ‚Äî you write zero validation code.

---

## Step 7 ‚Äî üíª LOCAL: Build the Auth Service Layer

**`backend/app/services/auth.py`** ‚Äî the core business logic:

### Register flow:
```
1. Check if email already exists ‚Üí 400 "Email already registered"
2. Check if username already taken ‚Üí 400 "Username taken"
3. Hash the password
4. Create user in DB (is_verified=False)
5. Generate 24hr verification token
6. Store token in DB
7. Send verification email via Brevo
8. Return access_token + refresh_token + user data
```

### Login flow:
```
1. Look up user by email ‚Üí 401 "Invalid credentials" if not found
2. Verify password hash ‚Üí 401 "Invalid credentials" if wrong
3. Check is_verified ‚Üí 403 "Please verify your email first"
4. Check is_active ‚Üí 403 "Account suspended"
5. Return access_token + refresh_token + user data
```

### Google OAuth flow:
```
1. Frontend sends the Google ID token (from Google Sign-In button)
2. Backend verifies the token with Google's API
3. Extract email from verified token
4. Check if user exists with that email:
   - Yes ‚Üí log them in
   - No ‚Üí create new account (no password, is_verified=True automatically)
5. Return access_token + refresh_token + user data
```

> **Why return tokens immediately on register?** Users expect to be logged in right after signing up. They still need to verify their email to post, but they can browse immediately.

---

## Step 8 ‚Äî üíª LOCAL: Build the API Endpoints

**`backend/app/api/v1/auth.py`** ‚Äî the HTTP layer. 6 endpoints:

| Method | Path | What it does |
|---|---|---|
| `POST` | `/auth/register` | Create account + send verification email |
| `POST` | `/auth/login` | Login with email + password |
| `POST` | `/auth/google` | Login/register with Google ID token |
| `POST` | `/auth/verify-email` | Verify email via token from email link |
| `POST` | `/auth/forgot-password` | Send password reset email |
| `POST` | `/auth/reset-password` | Set new password via reset token |
| `POST` | `/auth/refresh` | Exchange refresh token for new access token |
| `GET`  | `/auth/me` | Get current user's info (requires auth) |

Wire them into `backend/main.py`:
```python
app.include_router(auth_router, prefix="/auth", tags=["auth"])
```

> Since Traefik strips `/api` prefix and FastAPI has `root_path="/api"`, the full URL is:
> `POST https://yotop10.com/api/auth/register`

---

## Step 9 ‚Äî üíª LOCAL: Add Anonymous Session Support

Anonymous users get a session token based on their device fingerprint (collected on the frontend):

```
Browser fingerprint = hash(user_agent + screen_resolution + timezone + language)
```

The frontend sends this fingerprint with every request from a non-logged-in user. The backend:
1. Looks up or creates an anonymous session for this fingerprint
2. Rate-limits anonymous sessions more aggressively (10 reactions/hour vs 100 for accounts)
3. Stores the fingerprint in the `users` table with `is_anonymous=True`

Anonymous users can: view all public content, react to posts
Anonymous users cannot: post, comment, follow, access communities

> This prevents casual vote manipulation while keeping the platform open to new visitors.

---

## Step 10 ‚Äî üíª LOCAL: Set Up NextAuth on the Frontend

NextAuth handles the session on the frontend side. It stores the JWT in an **httpOnly cookie** (the browser can't read it with JavaScript ‚Äî protects against XSS attacks).

**`frontend/src/app/api/auth/[...nextauth]/route.ts`** ‚Äî the NextAuth config:

```typescript
// Two providers: Credentials (email/password) and Google
providers: [
  CredentialsProvider({
    // calls POST /api/auth/login on the backend
    authorize: async (credentials) => {
      const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/auth/login`, ...)
      return res.user
    }
  }),
  GoogleProvider({
    // sends Google ID token to POST /api/auth/google on the backend
    clientId: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  })
]
```

**Session access in any page:**
```typescript
// Server component
const session = await getServerSession()

// Client component
const { data: session } = useSession()

// Protect a page (redirect to /login if not authenticated)
export { default } from "next-auth/middleware"
```

---

## Step 11 ‚Äî üíª LOCAL: Build the Auth UI Pages

Four pages to build in `frontend/src/app/`:

### `/signup` ‚Äî Registration page
- Email, username, display name, password fields
- Google Sign-In button (calls Google OAuth flow)
- On submit ‚Üí `POST /api/auth/register`
- On success ‚Üí show "Check your email" message
- Errors shown inline under each field

### `/login` ‚Äî Login page
- Email + password fields
- Google Sign-In button
- "Forgot password?" link
- On success ‚Üí redirect to `/` (or wherever they came from)

### `/verify-email` ‚Äî Email verification landing
- Reads `?token=...` from URL
- On load ‚Üí `POST /api/auth/verify-email` with the token
- Success state: "Email verified! You can now post."
- Error state: "Link expired. Send a new one."

### `/forgot-password` + `/reset-password`
- Forgot: Email field ‚Üí sends reset email
- Reset: Reads token from URL, shows new password + confirm fields

---

## Step 12 ‚Äî üíª LOCAL: Create the Alembic Migration

The M2 migration created the tables. M3 doesn't add new tables ‚Äî the auth fields (`password_hash`, `email_verify_token`, `reset_password_token`, `google_id`, etc.) are already in the `users` table from M2.

However, if you need to add the `anonymous_sessions` table:

```bash
cd backend
source .venv/bin/activate
alembic revision --autogenerate -m "add anonymous sessions table"
alembic upgrade head
```

> Always run `alembic upgrade head` after creating a new revision. On the server, the CI/CD deploy runs this automatically via the deploy.yml workflow.

---

## Step 13 ‚Äî üñ•Ô∏è SERVER: Verify Environment Variables

The auth system needs these in `docker/.env` on the server ‚Äî confirm they're set:

```bash
SECRET_KEY=<your 32-byte hex key>              # JWT signing key
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=43200              # 30 days
GOOGLE_CLIENT_ID=<your client ID>
GOOGLE_CLIENT_SECRET=<your client secret>
BREVO_API_KEY=<your Brevo API key>
EMAIL_FROM=noreply@yotop10.com
NEXTAUTH_SECRET=<your nextauth secret>
NEXTAUTH_URL=https://yotop10.com
```

---

## Step 14 ‚Äî üñ•Ô∏è SERVER: Deploy & Verify

After writing all code locally and pushing to GitHub (which auto-deploys via CI/CD):

```bash
# Test registration
curl -X POST https://yotop10.com/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test1234","username":"testuser","display_name":"Test User"}'

# Expected response:
# {"access_token": "...", "refresh_token": "...", "user": {...}}

# Test login
curl -X POST https://yotop10.com/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test1234"}'

# Test protected route
curl https://yotop10.com/api/auth/me \
  -H "Authorization: Bearer <access_token_from_above>"

# Expected: {"id": "...", "username": "testuser", "is_verified": false, ...}
```

Check your email ‚Äî the verification email should arrive within 60 seconds of registering.

---

## M3 Completion Checklist

- [ ] `POST /api/auth/register` creates user + sends email ‚úì
- [ ] `POST /api/auth/login` returns JWT on valid credentials ‚úì
- [ ] `POST /api/auth/google` creates/logs in via Google ‚úì
- [ ] `POST /api/auth/verify-email` marks account verified ‚úì
- [ ] `POST /api/auth/forgot-password` sends reset email ‚úì
- [ ] `POST /api/auth/reset-password` updates password ‚úì
- [ ] `GET /api/auth/me` returns user data (auth required) ‚úì
- [ ] JWT stored in httpOnly cookie by NextAuth ‚úì
- [ ] `/signup`, `/login`, `/verify-email`, `/reset-password` pages built ‚úì
- [ ] Anonymous fingerprint sessions working ‚úì
- [ ] All verified with live `curl` tests ‚úì
