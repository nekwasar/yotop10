# M1 â€” Project Foundation (Fully Containerized, Multi-App Server Safe)

> **Goal**: A fully containerized YoTop10 stack running in Docker with Traefik as the shared server-wide reverse proxy. Every component â€” Next.js, FastAPI, PostgreSQL, Redis, MinIO â€” runs in Docker. Zero port conflicts with other apps. By the end of M1, `https://yotop10.com` returns the Next.js default page and `https://yotop10.com/api/health` returns `{"status": "ok"}`.

---

## Architecture Overview

```
Server (bare metal / VPS)
â”‚
â”œâ”€â”€ Traefik container          â† shared reverse proxy for ALL apps on server
â”‚   â”œâ”€â”€ Port 80 (HTTP â†’ redirect HTTPS)
â”‚   â”œâ”€â”€ Port 443 (HTTPS, Let's Encrypt auto SSL)
â”‚   â””â”€â”€ traefik-public network â† all apps connect here
â”‚
â””â”€â”€ yotop10 stack (own Docker network: yotop10_net)
    â”œâ”€â”€ frontend   (Next.js, port 3000 internal)
    â”œâ”€â”€ backend    (FastAPI, port 8000 internal)
    â”œâ”€â”€ postgres   (port 5432 internal only)
    â”œâ”€â”€ redis      (port 6379 internal only)
    â””â”€â”€ minio      (port 9000/9001 internal only)
```

**Key rules:**
- Traefik is installed **once** on the server and shared by all apps
- Each app lives in its own Docker network â€” completely isolated from other apps
- Apps expose themselves to Traefik via **Docker labels** â€” no manual config files per app
- No host ports are opened except 80 and 443 (Traefik) and SSH

---

## ðŸ’» Professional Workflow â€” Local vs Server

> **Write everything locally. The server only runs it.**
> The server is a runtime, not a workplace. Never SSH in to edit code.

```
Your Local Machine          GitHub            Server
------------------          ------            ------
Write all code       push   repo    CI/CD     docker compose up
Create all files  â”€â”€â”€â”€â”€â”€â”€â”€â–º (source â”€â”€â”€â”€â”€â”€â”€â”€â–º (server auto-deploys)
Run/test locally            of truth)         git pull on every push
```

| Task | Where |
|---|---|
| Writing Next.js / FastAPI code | ðŸ’» Local |
| Creating folder structure & files | ðŸ’» Local |
| Writing Dockerfiles & docker-compose | ðŸ’» Local |
| Git commits and pushes | ðŸ’» Local |
| Server hardening (UFW, SSH keys) | ðŸ–¥ï¸ Server â€” one time only |
| Installing Docker | ðŸ–¥ï¸ Server â€” one time only |
| Setting up Traefik at `/opt/traefik` | ðŸ–¥ï¸ Server â€” one time only |
| Creating `.env` with real secrets | ðŸ–¥ï¸ Server â€” never in git |
| Running the app | ðŸ–¥ï¸ Server â€” automated via CI/CD |

> **Syncing**: GitHub is the source of truth. When you `git push`, GitHub Actions automatically SSHs into the server, runs `git pull`, rebuilds Docker images, and restarts containers. The server is always in sync with the `main` branch. Zero manual server file editing after initial setup.

---

## Prerequisites

- Ubuntu 22.04 LTS server (fresh)
- SSH access as a non-root sudo user
- Domain `yotop10.com` pointing to server IP via Cloudflare (A record, proxy **OFF** for SSL to work â€” or use Cloudflare's flexible SSL mode)
- Git installed locally

> **Cloudflare note**: Set DNS proxy to **DNS only** (grey cloud) during setup so Let's Encrypt can verify your domain. Do this for **both** `yotop10.com` AND `cdn.yotop10.com`. You can re-enable proxy after SSL is issued.

---

## Step 1 â€” ðŸ–¥ï¸ SERVER: Hardening & Base Setup

```bash
# Update system
sudo apt update && sudo apt upgrade -y

# Install essentials
sudo apt install -y curl git ufw unzip

# Firewall â€” only SSH, HTTP, HTTPS
sudo ufw allow OpenSSH
sudo ufw allow 80
sudo ufw allow 443
sudo ufw --force enable
sudo ufw status

# Create non-root sudo user (skip if already done)
# sudo adduser yotop10 && sudo usermod -aG sudo yotop10
```

---

## Step 2 â€” ðŸ–¥ï¸ SERVER: Install Docker & Docker Compose

```bash
curl -fsSL https://get.docker.com | sh
sudo usermod -aG docker $USER

# Log out and SSH back in so group takes effect
exit
# SSH back in as same user

# Verify
docker --version       # Docker 25+
docker compose version # v2.x
```

---

## Step 3 â€” ðŸ’» LOCAL: Install Node.js & Python

> These are only needed on your local dev machine, NOT on the server. The server runs everything inside Docker. But install locally for editing/testing:

```bash
# Node.js 20 via nvm (local machine)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
source ~/.bashrc
nvm install 20 && nvm use 20

# pnpm
npm install -g pnpm

# Python 3.11 + uv
sudo apt install -y python3.11 python3.11-venv
curl -LsSf https://astral.sh/uv/install.sh | sh
source ~/.bashrc
```

---

## Step 4 â€” ðŸ’» LOCAL + ðŸ–¥ï¸ SERVER: Create Folder Structure

> Create this structure on your **local machine** first. It becomes your git repo. The server will receive it via `git pull` during the first deploy. The only exception is `/opt/traefik` which is server-only (not in the git repo).

```bash
# Traefik lives at the server root level (shared by all apps)
sudo mkdir -p /opt/traefik
sudo chown $USER:$USER /opt/traefik

# YoTop10 app
mkdir -p /home/nekwasar/yotop10/{frontend,backend,docker}
```

Full directory layout:

```
/opt/traefik/                     â† server-wide, shared
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ traefik.yml
â””â”€â”€ acme.json                     â† SSL certs (chmod 600)

/home/nekwasar/yotop10/           â† this repo
â”œâ”€â”€ frontend/                     â† Next.js app + Dockerfile
â”œâ”€â”€ backend/                      â† FastAPI app + Dockerfile
â”œâ”€â”€ docker/
â”‚   â””â”€â”€ docker-compose.yml        â† all yotop10 services
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â”œâ”€â”€ lint-test.yml
â”‚       â””â”€â”€ deploy.yml
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ milestones.md
â”œâ”€â”€ milestones/
â”œâ”€â”€ product_spec.md
â”œâ”€â”€ documentation_plan.md
â””â”€â”€ required.md
```

---

## Step 5 â€” ðŸ–¥ï¸ SERVER (ONE-TIME): Set Up Traefik

> This lives at `/opt/traefik` on the server only. It is **not** part of the git repo. Set it up once and never touch it again unless adding another app.

### 5a â€” Create Docker external network (shared by all apps)

```bash
docker network create traefik-public
```

### 5b â€” Create Traefik config

```bash
cd /opt/traefik

# Create acme.json for SSL certs â€” MUST be chmod 600
touch acme.json
chmod 600 acme.json
```

Create `/opt/traefik/traefik.yml`:

```yaml
global:
  checkNewVersion: false
  sendAnonymousUsage: false

log:
  level: INFO

api:
  dashboard: false   # set true + add auth if you want the Traefik dashboard

entryPoints:
  web:
    address: ":80"
    http:
      redirections:
        entryPoint:
          to: websecure
          scheme: https
          permanent: true

  websecure:
    address: ":443"

certificatesResolvers:
  letsencrypt:
    acme:
      email: your-email@example.com   # â† REPLACE with your real email
      storage: /acme.json
      httpChallenge:
        entryPoint: web

providers:
  docker:
    endpoint: "unix:///var/run/docker.sock"
    exposedByDefault: false           # containers must opt-in via labels
    network: traefik-public
```

Create `/opt/traefik/docker-compose.yml`:

```yaml
services:
  traefik:
    image: traefik:v3.1
    container_name: traefik
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./traefik.yml:/traefik.yml:ro
      - ./acme.json:/acme.json
    networks:
      - traefik-public

networks:
  traefik-public:
    external: true
```

Start Traefik:

```bash
cd /opt/traefik
docker compose up -d
docker compose logs -f   # watch for errors, Ctrl+C to exit
```

---

## Step 6 â€” ðŸ’» LOCAL: Create Frontend Dockerfile

Create `/home/nekwasar/yotop10/frontend/Dockerfile`:

```dockerfile
# Stage 1: Install dependencies
FROM node:20-alpine AS deps
WORKDIR /app
RUN npm install -g pnpm
COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile

# Stage 2: Build
FROM node:20-alpine AS builder
WORKDIR /app
RUN npm install -g pnpm
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN pnpm build

# Stage 3: Production runner
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
RUN npm install -g pnpm

COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

EXPOSE 3000
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

CMD ["node", "server.js"]
```

> **Important**: For the standalone output to work, add `output: "standalone"` to `next.config.ts` (done in Step 9).

Create `/home/nekwasar/yotop10/frontend/.dockerignore`:

```
node_modules
.next
.git
*.md
.env*
```

---

## Step 7 â€” ðŸ’» LOCAL: Create Backend Dockerfile

Create `/home/nekwasar/yotop10/backend/Dockerfile`:

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install uv
RUN pip install uv

# Install dependencies
COPY requirements.txt .
RUN uv pip install --system -r requirements.txt

# Copy app
COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

Create `/home/nekwasar/yotop10/backend/.dockerignore`:

```
__pycache__
*.pyc
.venv
.git
*.md
.env*
alembic/versions/
```

---

## Step 8 â€” ðŸ’» LOCAL: YoTop10 Docker Compose

> This file lives in `docker/docker-compose.yml` in your git repo. The server runs it via CI/CD â€” you never write it on the server.

```yaml
services:

  # â”€â”€â”€ Frontend (Next.js) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  frontend:
    build:
      context: ../frontend
      dockerfile: Dockerfile
    container_name: yotop10_frontend
    restart: unless-stopped
    environment:
      - NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
      - NEXTAUTH_URL=${NEXTAUTH_URL}
      - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}
      - GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
      - GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}
    networks:
      - yotop10_net
      - traefik-public
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.yotop10-frontend.rule=Host(`yotop10.com`) && !PathPrefix(`/api`)"
      - "traefik.http.routers.yotop10-frontend.entrypoints=websecure"
      - "traefik.http.routers.yotop10-frontend.tls.certresolver=letsencrypt"
      - "traefik.http.services.yotop10-frontend.loadbalancer.server.port=3000"
    depends_on:
      - backend

  # â”€â”€â”€ Backend (FastAPI) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  backend:
    build:
      context: ../backend
      dockerfile: Dockerfile
    container_name: yotop10_backend
    restart: unless-stopped
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - SECRET_KEY=${SECRET_KEY}
      - ALGORITHM=${ALGORITHM}
      - ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}
      - CORS_ORIGINS=${CORS_ORIGINS}
      - BREVO_API_KEY=${BREVO_API_KEY}
      - EMAIL_FROM=${EMAIL_FROM}
      - MINIO_ENDPOINT=${MINIO_ENDPOINT}
      - MINIO_ACCESS_KEY=${MINIO_ACCESS_KEY}
      - MINIO_SECRET_KEY=${MINIO_SECRET_KEY}
      - MINIO_BUCKET=${MINIO_BUCKET}
      - MINIO_SECURE=${MINIO_SECURE}
    networks:
      - yotop10_net
      - traefik-public
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.yotop10-backend.rule=Host(`yotop10.com`) && PathPrefix(`/api`)"
      - "traefik.http.routers.yotop10-backend.entrypoints=websecure"
      - "traefik.http.routers.yotop10-backend.tls.certresolver=letsencrypt"
      - "traefik.http.middlewares.yotop10-strip-api.stripprefix.prefixes=/api"
      - "traefik.http.routers.yotop10-backend.middlewares=yotop10-strip-api"
      - "traefik.http.services.yotop10-backend.loadbalancer.server.port=8000"
    depends_on:
      - postgres
      - redis

  # â”€â”€â”€ PostgreSQL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  postgres:
    image: postgres:16-alpine
    container_name: yotop10_postgres
    restart: unless-stopped
    environment:
      - POSTGRES_DB=yotop10
      - POSTGRES_USER=yotop10_user
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - yotop10_net
    # No ports exposed to host â€” internal only

  # â”€â”€â”€ Redis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  redis:
    image: redis:7-alpine
    container_name: yotop10_redis
    restart: unless-stopped
    command: redis-server --save 60 1 --loglevel warning
    volumes:
      - redis_data:/data
    networks:
      - yotop10_net
    # No ports exposed to host â€” internal only

  # â”€â”€â”€ MinIO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  minio:
    image: minio/minio:latest
    container_name: yotop10_minio
    restart: unless-stopped
    command: server /data --console-address ":9001"
    environment:
      - MINIO_ROOT_USER=${MINIO_ACCESS_KEY}
      - MINIO_ROOT_PASSWORD=${MINIO_SECRET_KEY}
      - MINIO_BROWSER_REDIRECT_URL=https://cdn.yotop10.com/minio-console
    volumes:
      - minio_data:/data
    networks:
      - yotop10_net
      - traefik-public        # â† expose to Traefik for cdn subdomain
    labels:
      - "traefik.enable=true"
      # Public image serving on cdn.yotop10.com (port 9000 = S3 API)
      - "traefik.http.routers.yotop10-cdn.rule=Host(`cdn.yotop10.com`)"
      - "traefik.http.routers.yotop10-cdn.entrypoints=websecure"
      - "traefik.http.routers.yotop10-cdn.tls.certresolver=letsencrypt"
      - "traefik.http.routers.yotop10-cdn.service=yotop10-cdn-svc"
      - "traefik.http.services.yotop10-cdn-svc.loadbalancer.server.port=9000"
    # Admin console NOT exposed publicly â€” access via SSH tunnel only:
    # ssh -L 9001:localhost:9001 user@yourserver â†’ open http://localhost:9001

volumes:
  postgres_data:
  redis_data:
  minio_data:

networks:
  yotop10_net:
    internal: true          # â† completely internal, no outside access
  traefik-public:
    external: true          # â† shared Traefik network
```

Create `/home/nekwasar/yotop10/docker/.env`:

```bash
cat > /home/nekwasar/yotop10/docker/.env << 'EOF'
# === NEXT.JS ===
NEXTAUTH_SECRET=generate_with_openssl_rand_base64_32
NEXTAUTH_URL=https://yotop10.com
NEXT_PUBLIC_API_URL=https://yotop10.com/api

# === GOOGLE OAUTH ===
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret

# === DATABASE ===
POSTGRES_PASSWORD=choose_a_strong_password
DATABASE_URL=postgresql://yotop10_user:choose_a_strong_password@postgres:5432/yotop10

# === REDIS ===
REDIS_URL=redis://redis:6379

# === FASTAPI ===
SECRET_KEY=generate_with_openssl_rand_hex_32
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=43200
CORS_ORIGINS=["https://yotop10.com"]

# === EMAIL ===
BREVO_API_KEY=your_brevo_api_key
EMAIL_FROM=noreply@yotop10.com

# === MINIO ===
MINIO_ENDPOINT=minio:9000
MINIO_ACCESS_KEY=choose_an_access_key
MINIO_SECRET_KEY=choose_a_very_long_secret_key_min_8_chars
MINIO_BUCKET=yotop10-media
MINIO_SECURE=false
NEXT_PUBLIC_CDN_URL=https://cdn.yotop10.com
EOF
```

> **Critical**: In Docker Compose, services talk to each other by **container name**, not `localhost`. That's why `DATABASE_URL` uses `postgres:5432` and `REDIS_URL` uses `redis:6379`.

---

## Step 9 â€” ðŸ’» LOCAL: Scaffold Next.js Frontend

On your **local machine**:

```bash
cd /home/nekwasar/yotop10

npx create-next-app@latest frontend \
  --typescript \
  --tailwind=false \
  --eslint \
  --app \
  --src-dir \
  --import-alias "@/*" \
  --no-git

cd frontend
```

Install dependencies:

```bash
pnpm add \
  next-auth@beta \
  axios \
  zustand \
  @tanstack/react-query \
  react-hook-form \
  zod \
  @hookform/resolvers \
  clsx \
  next-intl

pnpm add -D @types/node @types/react @types/react-dom typescript eslint prettier
```

Update `frontend/next.config.ts`:

```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  output: "standalone",       // â† required for Docker multi-stage build
  images: {
    remotePatterns: [
      {
        // Internal Docker access (backend-side image processing)
        protocol: "http",
        hostname: "minio",
        port: "9000",
      },
      {
        // Public CDN subdomain (frontend image tags use this)
        protocol: "https",
        hostname: "cdn.yotop10.com",
      },
      {
        protocol: "https",
        hostname: "yotop10.com",
      },
    ],
  },
};

export default nextConfig;
```

> **Image URL pattern**: When storing images in MinIO, save the path as `/yotop10-media/filename.jpg`.
> When serving in the frontend, construct URLs as `https://cdn.yotop10.com/yotop10-media/filename.jpg`.
> Use the env var `NEXT_PUBLIC_CDN_URL` (set to `https://cdn.yotop10.com`) as the base.

Create `frontend/src/app/layout.tsx`:

```typescript
import type { Metadata } from "next";
import { Outfit } from "next/font/google";
import "./globals.css";

const outfit = Outfit({
  subsets: ["latin"],
  variable: "--font-outfit",
});

export const metadata: Metadata = {
  title: "YoTop10 â€” Fact Mine. Debate Ground.",
  description:
    "A futuristic platform for top lists, debates, and facts. Argue, counter, and rank everything.",
  openGraph: {
    title: "YoTop10",
    description: "Fact Mine. Debate Ground. Your list vs the world.",
    url: "https://yotop10.com",
    siteName: "YoTop10",
    type: "website",
  },
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={`${outfit.variable} antialiased`}>{children}</body>
    </html>
  );
}
```

Create `frontend/src/app/page.tsx`:

```typescript
export default function Home() {
  return (
    <main>
      <h1>YoTop10</h1>
      <p>Coming soon.</p>
    </main>
  );
}
```

---

## Step 10 â€” ðŸ’» LOCAL: Scaffold FastAPI Backend

On your **local machine**:

```bash
cd /home/nekwasar/yotop10/backend

uv venv && source .venv/bin/activate

cat > requirements.txt << 'EOF'
fastapi==0.115.0
uvicorn[standard]==0.30.0
sqlalchemy==2.0.35
alembic==1.13.3
psycopg2-binary==2.9.9
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.12
pydantic==2.9.2
pydantic-settings==2.5.2
redis==5.0.8
minio==7.2.8
httpx==0.27.2
sib-api-v3-sdk==7.6.0
python-dotenv==1.0.1
ruff==0.6.0
EOF

uv pip install -r requirements.txt
```

Create backend structure:

```bash
mkdir -p app/{api,core,models,schemas,crud,services,utils}
touch app/__init__.py \
      app/api/__init__.py \
      app/core/__init__.py \
      app/models/__init__.py \
      app/schemas/__init__.py \
      app/crud/__init__.py \
      app/services/__init__.py \
      app/utils/__init__.py
```

Create `backend/app/core/config.py`:

```python
from pydantic_settings import BaseSettings, SettingsConfigDict
import json


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", extra="ignore")

    APP_NAME: str = "YoTop10"
    DEBUG: bool = False

    DATABASE_URL: str
    REDIS_URL: str = "redis://redis:6379"

    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 43200

    CORS_ORIGINS: str = '["https://yotop10.com"]'

    BREVO_API_KEY: str = ""
    EMAIL_FROM: str = "noreply@yotop10.com"

    MINIO_ENDPOINT: str = "minio:9000"
    MINIO_ACCESS_KEY: str
    MINIO_SECRET_KEY: str
    MINIO_BUCKET: str = "yotop10-media"
    MINIO_SECURE: bool = False

    def get_cors_origins(self) -> list[str]:
        return json.loads(self.CORS_ORIGINS)


settings = Settings()
```

Create `backend/app/core/database.py`:

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20,
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

Create `backend/main.py`:

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.core.config import settings

app = FastAPI(
    title="YoTop10 API",
    description="Backend API for YoTop10",
    version="0.1.0",
    docs_url="/docs",
    redoc_url="/redoc",
    root_path="/api",          # â† tells FastAPI it's mounted at /api
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.get_cors_origins(),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/health")
def health_check():
    return {"status": "ok", "app": settings.APP_NAME}


@app.get("/")
def root():
    return {"message": "YoTop10 API is running"}
```

---

## Step 11 â€” ðŸ’» LOCAL: Set Up Alembic

```bash
cd /home/nekwasar/yotop10/backend
source .venv/bin/activate

alembic init alembic
```

Edit `backend/alembic.ini` â€” clear the default sqlalchemy.url:

```ini
sqlalchemy.url =
```

Replace `backend/alembic/env.py` entirely:

```python
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
from app.core.config import settings
from app.core.database import Base

import app.models  # noqa: F401 â€” import all models so Alembic detects them

config = context.config
config.set_main_option("sqlalchemy.url", settings.DATABASE_URL)

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata


def run_migrations_offline() -> None:
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        pool_class=pool.NullPool,
    )
    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
        )
        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
```

---

## Step 12 â€” ðŸ’» LOCAL: Root .gitignore & .env.example

Create `/home/nekwasar/yotop10/.gitignore`:

```gitignore
# Environment
.env
.env.local
.env.production
docker/.env

# Node
node_modules/
.next/
out/
dist/

# Python
__pycache__/
*.pyc
*.pyo
.venv/
*.egg-info/

# Docker volumes
docker/volumes/

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/
```

Create `/home/nekwasar/yotop10/.env.example`:

```env
# NEXT.JS
NEXTAUTH_SECRET=
NEXTAUTH_URL=https://yotop10.com
NEXT_PUBLIC_API_URL=https://yotop10.com/api

# GOOGLE OAUTH
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=

# DATABASE
POSTGRES_PASSWORD=
DATABASE_URL=postgresql://yotop10_user:POSTGRES_PASSWORD@postgres:5432/yotop10

# REDIS
REDIS_URL=redis://redis:6379

# FASTAPI
SECRET_KEY=
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=43200
CORS_ORIGINS=["https://yotop10.com"]

# EMAIL
BREVO_API_KEY=
EMAIL_FROM=noreply@yotop10.com

# MINIO
MINIO_ENDPOINT=minio:9000
MINIO_ACCESS_KEY=
MINIO_SECRET_KEY=
MINIO_BUCKET=yotop10-media
MINIO_SECURE=false
```

---

## Step 13 â€” ðŸ’» LOCAL: GitHub Actions CI/CD Workflows

Create `.github/workflows/lint-test.yml`:

```yaml
name: Lint & Test

on:
  pull_request:
    branches: [main]

jobs:
  frontend-lint:
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
      - name: Install pnpm + deps
        run: |
          npm install -g pnpm
          cd frontend && pnpm install
      - name: Lint
        run: cd frontend && pnpm lint

  backend-lint:
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python & lint
        run: |
          cd backend
          python3.11 -m venv .venv
          .venv/bin/pip install uv
          .venv/bin/uv pip install ruff
          .venv/bin/ruff check .
```

Create `.github/workflows/deploy.yml`:

```yaml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: self-hosted
    steps:
      - name: Pull latest code
        run: git -C /home/nekwasar/yotop10 pull origin main

      - name: Rebuild and restart containers
        run: |
          cd /home/nekwasar/yotop10/docker
          docker compose build --no-cache
          docker compose up -d --force-recreate

      - name: Run database migrations
        run: |
          docker compose -f /home/nekwasar/yotop10/docker/docker-compose.yml \
            exec backend alembic upgrade head

      - name: Clean up old images
        run: docker image prune -f
```

---

## Step 14 â€” ðŸ–¥ï¸ SERVER (ONE-TIME): Self-Hosted GitHub Actions Runner

> This is the runner that executes your CI/CD workflows directly on the server. Set it up once.

On the server:

```bash
mkdir ~/actions-runner && cd ~/actions-runner

# Go to: GitHub repo â†’ Settings â†’ Actions â†’ Runners â†’ New self-hosted runner
# Choose Linux x64 and follow the exact commands GitHub gives you
# They provide a unique token â€” the commands look like:

# Download
curl -o actions-runner-linux-x64-2.x.x.tar.gz -L https://github.com/actions/runner/releases/...
tar xzf ./actions-runner-linux-x64-2.x.x.tar.gz

# Configure (use the exact token from GitHub)
./config.sh --url https://github.com/YOUR_USERNAME/yotop10 --token YOUR_TOKEN

# Install as system service (survives reboots)
sudo ./svc.sh install
sudo ./svc.sh start
```

---

## Step 15 â€” ðŸ–¥ï¸ SERVER: Create Real `.env` File

> **Never commit real secrets to git.** The `.env` in `docker/` only lives on the server. Copy `.env.example` from the repo and fill in real values.

```bash
# On the server after first git pull:
cp /home/nekwasar/yotop10/docker/.env.example /home/nekwasar/yotop10/docker/.env
nano /home/nekwasar/yotop10/docker/.env   # fill in all real values
```

After containers are running, create the media bucket via SSH tunnel:

```bash
# On server â€” exec into minio container to create bucket
docker exec -it yotop10_minio sh

# Inside container:
mc alias set local http://localhost:9000 $MINIO_ROOT_USER $MINIO_ROOT_PASSWORD
mc mb local/yotop10-media
mc anonymous set download local/yotop10-media
exit
```

Alternatively, SSH tunnel to MinIO console on your local machine:

```bash
ssh -L 9001:localhost:9001 user@yourserver
# Then open http://localhost:9001 in browser
```

---

## Step 16 â€” ðŸ’» LOCAL: Initialize Git & Push

> This is the moment your local code goes to GitHub. After this, every future `git push` to `main` auto-deploys to the server via the CI/CD runner.

```bash
cd /home/nekwasar/yotop10

git init
git branch -M main
git add .
git commit -m "feat: M1 complete â€” fully containerized stack with Traefik"

git remote add origin https://github.com/YOUR_USERNAME/yotop10.git
git push -u origin main
```

---

## Step 17 â€” ðŸ–¥ï¸ SERVER: First Deploy + MinIO Bucket Setup

> The CI/CD runner handles this automatically after `git push`. But for the very first deploy, run manually on the server to verify everything:

```bash
# Pull code for the first time
cd /home/nekwasar/yotop10
git pull origin main

# Start all containers
cd docker
docker compose up -d --build

# Watch logs
docker compose logs -f

# Confirm all running
docker compose ps
```

### Create MinIO Bucket (first deploy only)

```bash
docker exec -it yotop10_minio sh

# Inside container:
mc alias set local http://localhost:9000 $MINIO_ROOT_USER $MINIO_ROOT_PASSWORD
mc mb local/yotop10-media
mc anonymous set download local/yotop10-media
exit
```

Expected output:

```
NAME                    STATUS          PORTS
yotop10_frontend        Up              (internal)
yotop10_backend         Up              (internal)
yotop10_postgres        Up              (internal)
yotop10_redis           Up              (internal)
yotop10_minio           Up              (internal)
```

---

## Step 18 â€” Verify Everything Works

```bash
# Hit health endpoint
curl https://yotop10.com/api/health
# Expected: {"status": "ok", "app": "YoTop10"}

# Hit frontend
curl -I https://yotop10.com
# Expected: HTTP/2 200

# Check SSL cert
curl -vI https://yotop10.com 2>&1 | grep "subject\|issuer"
# Expected: Let's Encrypt cert
```

---

## âœ… M1 Completion Checklist

- [ ] Traefik running at `/opt/traefik` with `traefik-public` Docker network
- [ ] SSL auto-issued for `yotop10.com` via Let's Encrypt
- [ ] All 5 YoTop10 containers running (frontend, backend, postgres, redis, minio)
- [ ] `https://yotop10.com` â†’ Next.js page âœ…
- [ ] `https://yotop10.com/api/health` â†’ `{"status":"ok"}` âœ…
- [ ] MinIO bucket `yotop10-media` created with public-read policy
- [ ] Alembic initialized (empty â€” models added in M2)
- [ ] GitHub repo live with code pushed
- [ ] Self-hosted GitHub Actions runner online
- [ ] CI/CD deploys automatically on push to `main`
- [ ] No host ports open except 80, 443, SSH

---

## Adding Other Apps Later (Zero Conflict Guide)

When you add another app to this server:

```bash
# 1. Create its folder
mkdir /home/nekwasar/my-other-app

# 2. Add its own docker-compose.yml with its own network
#    and Traefik labels pointing to its domain

# 3. Connect it to traefik-public network:
networks:
  my_other_app_net:
    internal: true
  traefik-public:
    external: true

# 4. That's it. No Traefik config needed.
#    New domain + SSL auto-configured from labels alone.
```

---

## Notes for M2

- Do NOT write any database models during M1
- `app/models/__init__.py` stays empty until M2
- The `Base` in `database.py` is ready â€” M2 imports from it and defines all tables
- Alembic will run its first `upgrade head` in M2 after models are defined
- Database hostname inside Docker is `postgres` (container name), not `localhost`
