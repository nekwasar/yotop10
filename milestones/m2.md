# M2 ‚Äî Database Schema

> **Goal**: Define every SQLAlchemy model, run the first Alembic migration, and verify all tables exist in PostgreSQL. By the end of M2, the database has all tables needed to support every YoTop10 feature ‚Äî even ones not built until later milestones.

---

## Overview of Tables

| Model File | Tables |
|---|---|
| `user.py` | `users` |
| `category.py` | `categories` |
| `post.py` | `posts`, `post_sources`, `pinned_posts`, `post_communities` |
| `list_item.py` | `list_items` |
| `community.py` | `communities`, `community_members` |
| `comment.py` | `comments` |
| `reaction.py` | `reactions` |
| `social.py` | `follows`, `connections` |
| `badge.py` | `badges`, `user_badges` |
| `moderation.py` | `reports`, `strikes`, `auto_hide_rules` |
| `ephemeral.py` | `ephemeral_threads`, `ephemeral_thread_participants`, `ephemeral_thread_messages` |

---

## Step 1 ‚Äî Install uuid-ossp Extension

Connect to PostgreSQL and enable the UUID extension:

```bash
# From server ‚Äî exec into the postgres container
docker exec -it yotop10_postgres psql -U yotop10_user -d yotop10

-- Inside psql:
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
\q
```

---

## Step 2 ‚Äî Create All Model Files

### `backend/app/models/__init__.py`

This file imports all models so Alembic can auto-detect them:

```python
from app.models.user import User
from app.models.category import Category
from app.models.post import Post, PostSource, PinnedPost, PostCommunity
from app.models.list_item import ListItem
from app.models.community import Community, CommunityMember
from app.models.comment import Comment
from app.models.reaction import Reaction
from app.models.social import Follow, Connection
from app.models.badge import Badge, UserBadge
from app.models.moderation import Report, Strike, AutoHideRule
from app.models.ephemeral import EphemeralThread, EphemeralThreadParticipant, EphemeralThreadMessage

__all__ = [
    "User",
    "Category",
    "Post", "PostSource", "PinnedPost", "PostCommunity",
    "ListItem",
    "Community", "CommunityMember",
    "Comment",
    "Reaction",
    "Follow", "Connection",
    "Badge", "UserBadge",
    "Report", "Strike", "AutoHideRule",
    "EphemeralThread", "EphemeralThreadParticipant", "EphemeralThreadMessage",
]
```

---

### `backend/app/models/user.py`

```python
import uuid
from datetime import datetime
from sqlalchemy import (
    Column, String, Boolean, Integer, DateTime,
    Enum as SAEnum, Text, ForeignKey
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
import enum


class AuthProvider(str, enum.Enum):
    email = "email"
    google = "google"
    anonymous = "anonymous"


class ThemePreference(str, enum.Enum):
    futuristic = "futuristic"
    retro = "retro"


class ColorMode(str, enum.Enum):
    dark = "dark"
    light = "light"


class ProfileVisibility(str, enum.Enum):
    public = "public"
    connections_only = "connections_only"
    private = "private"


class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String(50), unique=True, nullable=False, index=True)
    display_name = Column(String(100), nullable=False)

    # Auth
    email = Column(String(255), unique=True, nullable=True, index=True)
    hashed_password = Column(String(255), nullable=True)
    auth_provider = Column(SAEnum(AuthProvider), nullable=False, default=AuthProvider.email)
    is_anonymous = Column(Boolean, default=False, nullable=False)
    device_fingerprint = Column(String(255), nullable=True)  # for anonymous accounts

    # Profile
    avatar_url = Column(String(500), nullable=True)
    bio = Column(Text, nullable=True)
    custom_profile_html = Column(Text, nullable=True)  # Spacehey-style
    custom_profile_css = Column(Text, nullable=True)

    # Preferences
    theme_preference = Column(SAEnum(ThemePreference), default=ThemePreference.futuristic)
    color_mode = Column(SAEnum(ColorMode), default=ColorMode.dark)
    profile_visibility = Column(SAEnum(ProfileVisibility), default=ProfileVisibility.public)
    post_default_visibility = Column(SAEnum(ProfileVisibility), default=ProfileVisibility.public)
    email_digest_opt_in = Column(Boolean, default=True)

    # Author tier
    is_author = Column(Boolean, default=False, nullable=False)
    approved_post_count = Column(Integer, default=0, nullable=False)

    # Roles
    is_admin = Column(Boolean, default=False, nullable=False)

    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    is_suspended = Column(Boolean, default=False, nullable=False)
    suspension_until = Column(DateTime, nullable=True)
    is_banned = Column(Boolean, default=False, nullable=False)

    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    posts = relationship("Post", back_populates="author", foreign_keys="Post.author_id")
    comments = relationship("Comment", back_populates="author")
    reactions = relationship("Reaction", back_populates="user")
    following = relationship("Follow", back_populates="follower", foreign_keys="Follow.follower_id")
    followers = relationship("Follow", back_populates="following", foreign_keys="Follow.following_id")
    sent_connections = relationship("Connection", back_populates="requester", foreign_keys="Connection.requester_id")
    received_connections = relationship("Connection", back_populates="receiver", foreign_keys="Connection.receiver_id")
    badges = relationship("UserBadge", back_populates="user")
    strikes = relationship("Strike", back_populates="user", foreign_keys="Strike.user_id")
    community_memberships = relationship("CommunityMember", back_populates="user")
```

---

### `backend/app/models/category.py`

```python
import uuid
from datetime import datetime
from sqlalchemy import Column, String, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base


class Category(Base):
    __tablename__ = "categories"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(100), unique=True, nullable=False)
    slug = Column(String(100), unique=True, nullable=False, index=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    posts = relationship("Post", back_populates="category")
```

Seed data (run after first migration):

```python
# Categories to insert ‚Äî run this once in a setup script or Alembic seed
CATEGORIES = [
    ("Film & TV", "film-tv"),
    ("Music", "music"),
    ("Sports", "sports"),
    ("Science & Tech", "science-tech"),
    ("History", "history"),
    ("Politics", "politics"),
    ("Food & Drink", "food-drink"),
    ("Travel", "travel"),
    ("Gaming", "gaming"),
    ("Books & Literature", "books-literature"),
    ("Pop Culture", "pop-culture"),
    ("Business", "business"),
    ("Environment", "environment"),
    ("Philosophy", "philosophy"),
    ("True Crime", "true-crime"),
    ("Other", "other"),
]
```

---

### `backend/app/models/post.py`

```python
import uuid
from datetime import datetime
from sqlalchemy import (
    Column, String, Boolean, Integer, DateTime, Text,
    Enum as SAEnum, ForeignKey
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
import enum


class PostType(str, enum.Enum):
    top_list = "top_list"
    this_vs_that = "this_vs_that"
    who_is_better = "who_is_better"
    fact_drop = "fact_drop"
    best_of = "best_of"
    worst_of = "worst_of"
    hidden_gems = "hidden_gems"
    counter_list = "counter_list"


class PostStatus(str, enum.Enum):
    draft = "draft"
    pending_review = "pending_review"
    approved = "approved"
    rejected = "rejected"
    hidden = "hidden"  # auto-hidden by moderation rules


class PostVisibility(str, enum.Enum):
    public = "public"
    connections_only = "connections_only"
    private = "private"


class VerdictStatus(str, enum.Enum):
    undecided = "undecided"
    confirmed = "confirmed"
    contested = "contested"
    hot_take = "hot_take"
    debunked = "debunked"


class PinType(str, enum.Enum):
    global_feed = "global_feed"
    community = "community"


class Post(Base):
    __tablename__ = "posts"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    author_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    title = Column(String(300), nullable=False)
    post_type = Column(SAEnum(PostType), nullable=False)
    status = Column(SAEnum(PostStatus), default=PostStatus.pending_review, nullable=False, index=True)
    visibility = Column(SAEnum(PostVisibility), default=PostVisibility.public, nullable=False)

    # Content
    intro = Column(Text, nullable=True)  # optional intro before list items
    is_sourced = Column(Boolean, default=False)

    # Category
    category_id = Column(UUID(as_uuid=True), ForeignKey("categories.id"), nullable=True, index=True)

    # Counter list ‚Äî links to the original post being countered
    counter_to_post_id = Column(UUID(as_uuid=True), ForeignKey("posts.id", ondelete="SET NULL"), nullable=True)

    # Verdict (computed periodically from reactions + engagement)
    verdict = Column(SAEnum(VerdictStatus), default=VerdictStatus.undecided)

    # Engagement counters (denormalized for fast feed queries)
    fire_count = Column(Integer, default=0, nullable=False)
    comment_count = Column(Integer, default=0, nullable=False)
    challenge_count = Column(Integer, default=0, nullable=False)
    rival_count = Column(Integer, default=0, nullable=False)  # number of counter lists

    # Edit window ‚Äî 2 hours after approval
    edit_deadline = Column(DateTime, nullable=True)
    approved_at = Column(DateTime, nullable=True)
    rejected_reason = Column(Text, nullable=True)

    created_at = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    author = relationship("User", back_populates="posts", foreign_keys=[author_id])
    category = relationship("Category", back_populates="posts")
    list_items = relationship("ListItem", back_populates="post", order_by="ListItem.rank", cascade="all, delete-orphan")
    sources = relationship("PostSource", back_populates="post", cascade="all, delete-orphan")
    comments = relationship("Comment", back_populates="post", cascade="all, delete-orphan")
    reactions = relationship("Reaction", primaryjoin="and_(Reaction.target_type=='post', foreign(Reaction.target_id)==Post.id)")
    counter_lists = relationship("Post", foreign_keys=[counter_to_post_id])
    pinned = relationship("PinnedPost", back_populates="post", cascade="all, delete-orphan")
    communities = relationship("PostCommunity", back_populates="post", cascade="all, delete-orphan")


class PostSource(Base):
    __tablename__ = "post_sources"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    post_id = Column(UUID(as_uuid=True), ForeignKey("posts.id", ondelete="CASCADE"), nullable=False)
    label = Column(String(200), nullable=False)
    url = Column(String(1000), nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    post = relationship("Post", back_populates="sources")


class PinnedPost(Base):
    __tablename__ = "pinned_posts"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    post_id = Column(UUID(as_uuid=True), ForeignKey("posts.id", ondelete="CASCADE"), nullable=False)
    pinned_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    pin_type = Column(SAEnum(PinType), nullable=False)
    community_id = Column(UUID(as_uuid=True), ForeignKey("communities.id", ondelete="CASCADE"), nullable=True)
    pinned_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=True)

    post = relationship("Post", back_populates="pinned")


class PostCommunity(Base):
    """Many-to-many: a post can be posted into a community."""
    __tablename__ = "post_communities"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    post_id = Column(UUID(as_uuid=True), ForeignKey("posts.id", ondelete="CASCADE"), nullable=False)
    community_id = Column(UUID(as_uuid=True), ForeignKey("communities.id", ondelete="CASCADE"), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    post = relationship("Post", back_populates="communities")
    community = relationship("Community", back_populates="posts")
```

---

### `backend/app/models/list_item.py`

```python
import uuid
from datetime import datetime
from sqlalchemy import Column, String, Integer, DateTime, Text, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base


class ListItem(Base):
    __tablename__ = "list_items"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    post_id = Column(UUID(as_uuid=True), ForeignKey("posts.id", ondelete="CASCADE"), nullable=False, index=True)
    rank = Column(Integer, nullable=False)           # 1 = top ranked
    title = Column(String(300), nullable=False)
    description = Column(Text, nullable=False)       # written justification
    image_url = Column(String(500), nullable=True)

    # Engagement counters
    fire_count = Column(Integer, default=0, nullable=False)
    challenge_count = Column(Integer, default=0, nullable=False)

    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    post = relationship("Post", back_populates="list_items")
    comments = relationship("Comment", back_populates="list_item")
```

---

### `backend/app/models/community.py`

```python
import uuid
from datetime import datetime
from sqlalchemy import Column, String, Boolean, DateTime, Text, ForeignKey
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from app.core.database import Base


class Community(Base):
    __tablename__ = "communities"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(100), unique=True, nullable=False)
    slug = Column(String(100), unique=True, nullable=False, index=True)
    description = Column(Text, nullable=True)
    banner_url = Column(String(500), nullable=True)
    rules = Column(Text, nullable=True)
    is_archived = Column(Boolean, default=False, nullable=False)
    created_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    members = relationship("CommunityMember", back_populates="community", cascade="all, delete-orphan")
    posts = relationship("PostCommunity", back_populates="community")
    ephemeral_threads = relationship("EphemeralThread", back_populates="community")


class CommunityMember(Base):
    __tablename__ = "community_members"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    community_id = Column(UUID(as_uuid=True), ForeignKey("communities.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    role = Column(String(20), default="member", nullable=False)  # "member" | "moderator"

    # Granular moderator permissions (only relevant when role = "moderator")
    # Stored as a list of permission strings, e.g.:
    # ["pin_posts", "remove_posts", "warn_members", "review_reports"]
    permissions = Column(JSONB, nullable=True, default=list)

    joined_at = Column(DateTime, default=datetime.utcnow)

    community = relationship("Community", back_populates="members")
    user = relationship("User", back_populates="community_memberships")
```

---

### `backend/app/models/comment.py`

```python
import uuid
from datetime import datetime
from sqlalchemy import Column, Integer, Boolean, DateTime, Text, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base


class Comment(Base):
    __tablename__ = "comments"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    post_id = Column(UUID(as_uuid=True), ForeignKey("posts.id", ondelete="CASCADE"), nullable=False, index=True)
    author_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)

    # Item-anchored comment ‚Äî highlights a specific list item
    list_item_id = Column(UUID(as_uuid=True), ForeignKey("list_items.id", ondelete="SET NULL"), nullable=True, index=True)

    # Nested replies (max depth 2 ‚Äî 0=top, 1=reply, 2=reply-to-reply)
    parent_comment_id = Column(UUID(as_uuid=True), ForeignKey("comments.id", ondelete="CASCADE"), nullable=True)
    depth = Column(Integer, default=0, nullable=False)

    content = Column(Text, nullable=False)

    # Engagement
    fire_count = Column(Integer, default=0, nullable=False)

    is_hidden = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    post = relationship("Post", back_populates="comments")
    author = relationship("User", back_populates="comments")
    list_item = relationship("ListItem", back_populates="comments")
    parent = relationship("Comment", remote_side="Comment.id", back_populates="replies")
    replies = relationship("Comment", back_populates="parent", cascade="all, delete-orphan")
```

---

### `backend/app/models/reaction.py`

```python
import uuid
from datetime import datetime
from sqlalchemy import Column, String, DateTime, ForeignKey, UniqueConstraint, Enum as SAEnum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
import enum


class ReactionType(str, enum.Enum):
    fire = "fire"
    # Future: verified, challenge, big_brain, buried


class ReactionTargetType(str, enum.Enum):
    post = "post"
    list_item = "list_item"
    comment = "comment"


class Reaction(Base):
    __tablename__ = "reactions"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    target_type = Column(SAEnum(ReactionTargetType), nullable=False)
    target_id = Column(UUID(as_uuid=True), nullable=False, index=True)  # post.id / list_item.id / comment.id
    reaction_type = Column(SAEnum(ReactionType), nullable=False, default=ReactionType.fire)
    created_at = Column(DateTime, default=datetime.utcnow)

    user = relationship("User", back_populates="reactions")

    __table_args__ = (
        UniqueConstraint("user_id", "target_type", "target_id", "reaction_type", name="uq_reaction_per_user"),
    )
```

---

### `backend/app/models/social.py`

```python
import uuid
from datetime import datetime
from sqlalchemy import Column, DateTime, ForeignKey, UniqueConstraint, Enum as SAEnum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
import enum


class ConnectionStatus(str, enum.Enum):
    pending = "pending"
    accepted = "accepted"
    declined = "declined"


class Follow(Base):
    __tablename__ = "follows"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    follower_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    following_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    follower = relationship("User", back_populates="following", foreign_keys=[follower_id])
    following = relationship("User", back_populates="followers", foreign_keys=[following_id])

    __table_args__ = (
        UniqueConstraint("follower_id", "following_id", name="uq_follow"),
    )


class Connection(Base):
    __tablename__ = "connections"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    requester_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    receiver_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    status = Column(SAEnum(ConnectionStatus), default=ConnectionStatus.pending, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    requester = relationship("User", back_populates="sent_connections", foreign_keys=[requester_id])
    receiver = relationship("User", back_populates="received_connections", foreign_keys=[receiver_id])

    __table_args__ = (
        UniqueConstraint("requester_id", "receiver_id", name="uq_connection"),
    )
```

---

### `backend/app/models/badge.py`

```python
import uuid
from datetime import datetime
from sqlalchemy import Column, String, DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base


class Badge(Base):
    __tablename__ = "badges"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(100), unique=True, nullable=False)
    slug = Column(String(100), unique=True, nullable=False)
    description = Column(String(300), nullable=False)
    icon = Column(String(10), nullable=False)  # emoji
    created_at = Column(DateTime, default=datetime.utcnow)

    user_badges = relationship("UserBadge", back_populates="badge")


class UserBadge(Base):
    __tablename__ = "user_badges"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    badge_id = Column(UUID(as_uuid=True), ForeignKey("badges.id"), nullable=False)
    awarded_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)  # null = auto-awarded
    awarded_at = Column(DateTime, default=datetime.utcnow)

    user = relationship("User", back_populates="badges", foreign_keys=[user_id])
    badge = relationship("Badge", back_populates="user_badges")
```

Seed badges (run once after migration):

```python
BADGES = [
    ("Author", "author", "20 posts approved for the public feed", "‚≠ê"),
    ("Hot Lister", "hot-lister", "3+ posts reached the Hot Takes page", "üî•"),
    ("Fact Master", "fact-master", "10+ posts with CONFIRMED community verdict", "‚úÖ"),
    ("Rival Champion", "rival-champion", "Won 3+ Battle View votes", "‚öîÔ∏è"),
    ("List of the Year", "list-of-the-year", "Annual best list award", "üèÜ"),
    ("Most Controversial", "most-controversial", "Most challenged posts in a month", "üíÄ"),
    ("Mind Changer", "mind-changer", "Highest Big Brain reactions on a post", "üß†"),
]
```

---

### `backend/app/models/moderation.py`

```python
import uuid
from datetime import datetime
from sqlalchemy import Column, String, Boolean, Integer, DateTime, Text, ForeignKey, Enum as SAEnum
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from app.core.database import Base
import enum


class ReportTargetType(str, enum.Enum):
    post = "post"
    comment = "comment"


class ReportStatus(str, enum.Enum):
    pending = "pending"
    dismissed = "dismissed"
    actioned = "actioned"


class StrikeConsequence(str, enum.Enum):
    warning = "warning"
    suspension = "suspension"
    ban = "ban"


class AutoHideRuleType(str, enum.Enum):
    report_threshold = "report_threshold"
    keyword_filter = "keyword_filter"
    anonymous_spam = "anonymous_spam"
    new_user_rate = "new_user_rate"
    engagement_anomaly = "engagement_anomaly"


class Report(Base):
    __tablename__ = "reports"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    reporter_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    target_type = Column(SAEnum(ReportTargetType), nullable=False)
    target_id = Column(UUID(as_uuid=True), nullable=False, index=True)
    community_id = Column(UUID(as_uuid=True), ForeignKey("communities.id", ondelete="SET NULL"), nullable=True)
    reason = Column(Text, nullable=False)
    status = Column(SAEnum(ReportStatus), default=ReportStatus.pending, nullable=False, index=True)
    resolved_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    resolved_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

    reporter = relationship("User", foreign_keys=[reporter_id])
    resolver = relationship("User", foreign_keys=[resolved_by])


class Strike(Base):
    __tablename__ = "strikes"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    issued_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    reason = Column(Text, nullable=False)
    strike_number = Column(Integer, nullable=False)  # which strike: 1, 2, 3
    consequence = Column(SAEnum(StrikeConsequence), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

    user = relationship("User", back_populates="strikes", foreign_keys=[user_id])
    issuer = relationship("User", foreign_keys=[issued_by])


class AutoHideRule(Base):
    __tablename__ = "auto_hide_rules"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    rule_type = Column(SAEnum(AutoHideRuleType), unique=True, nullable=False)
    is_enabled = Column(Boolean, default=True, nullable=False)

    # JSON config per rule type. Examples:
    # report_threshold: {"threshold": 5, "within_hours": 2}
    # keyword_filter: {"keywords": ["spam", "scam"]}
    # anonymous_spam: {"max_posts": 3, "within_minutes": 30}
    # new_user_rate: {"max_posts": 5, "within_hours": 1, "account_age_days": 7}
    # engagement_anomaly: {"same_day_account_reports": 3}
    config = Column(JSONB, nullable=False, default=dict)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

Seed auto-hide rules (run once after migration):

```python
AUTO_HIDE_RULES = [
    ("report_threshold", True, {"threshold": 5, "within_hours": 2}),
    ("keyword_filter", True, {"keywords": []}),
    ("anonymous_spam", True, {"max_posts": 3, "within_minutes": 30}),
    ("new_user_rate", True, {"max_posts": 5, "within_hours": 1, "account_age_days": 7}),
    ("engagement_anomaly", True, {"same_day_account_reports": 3}),
]
```

---

### `backend/app/models/ephemeral.py`

```python
import uuid
from datetime import datetime
from sqlalchemy import Column, String, Boolean, Integer, DateTime, Text, ForeignKey, Enum as SAEnum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
import enum


class BurnMode(str, enum.Enum):
    after_response = "after_response"   # burns X minutes after receiver replies
    before_seen = "before_seen"         # burns before receiver even reads it


class EphemeralThread(Base):
    __tablename__ = "ephemeral_threads"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    community_id = Column(UUID(as_uuid=True), ForeignKey("communities.id", ondelete="CASCADE"), nullable=False)
    creator_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    burn_mode = Column(SAEnum(BurnMode), nullable=False)
    burn_after_minutes = Column(Integer, nullable=False)  # minutes until destruction after trigger
    is_burned = Column(Boolean, default=False, nullable=False)
    burned_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    community = relationship("Community", back_populates="ephemeral_threads")
    creator = relationship("User")
    participants = relationship("EphemeralThreadParticipant", back_populates="thread", cascade="all, delete-orphan")
    messages = relationship("EphemeralThreadMessage", back_populates="thread", cascade="all, delete-orphan")


class EphemeralThreadParticipant(Base):
    __tablename__ = "ephemeral_thread_participants"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    thread_id = Column(UUID(as_uuid=True), ForeignKey("ephemeral_threads.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    has_seen = Column(Boolean, default=False)
    seen_at = Column(DateTime, nullable=True)
    joined_at = Column(DateTime, default=datetime.utcnow)

    thread = relationship("EphemeralThread", back_populates="participants")
    user = relationship("User")


class EphemeralThreadMessage(Base):
    __tablename__ = "ephemeral_thread_messages"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    thread_id = Column(UUID(as_uuid=True), ForeignKey("ephemeral_threads.id", ondelete="CASCADE"), nullable=False)
    author_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    content = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    thread = relationship("EphemeralThread", back_populates="messages")
    author = relationship("User")
```

---

## Step 3 ‚Äî Create Seed Script

Create `backend/app/utils/seed.py`:

```python
"""
Run once after first migration to populate categories, badges, and auto-hide rules.
Usage: python -m app.utils.seed
"""
from app.core.database import SessionLocal
from app.models.category import Category
from app.models.badge import Badge
from app.models.moderation import AutoHideRule, AutoHideRuleType

CATEGORIES = [
    ("Film & TV", "film-tv"), ("Music", "music"), ("Sports", "sports"),
    ("Science & Tech", "science-tech"), ("History", "history"), ("Politics", "politics"),
    ("Food & Drink", "food-drink"), ("Travel", "travel"), ("Gaming", "gaming"),
    ("Books & Literature", "books-literature"), ("Pop Culture", "pop-culture"),
    ("Business", "business"), ("Environment", "environment"), ("Philosophy", "philosophy"),
    ("True Crime", "true-crime"), ("Other", "other"),
]

BADGES = [
    ("Author", "author", "20 posts approved for the public feed", "‚≠ê"),
    ("Hot Lister", "hot-lister", "3+ posts reached the Hot Takes page", "üî•"),
    ("Fact Master", "fact-master", "10+ posts with CONFIRMED verdict", "‚úÖ"),
    ("Rival Champion", "rival-champion", "Won 3+ Battle View votes", "‚öîÔ∏è"),
    ("List of the Year", "list-of-the-year", "Annual best list award winner", "üèÜ"),
    ("Most Controversial", "most-controversial", "Most challenged posts in a month", "üíÄ"),
    ("Mind Changer", "mind-changer", "Highest Big Brain reactions on a post", "üß†"),
]

AUTO_HIDE_RULES = [
    (AutoHideRuleType.report_threshold, True, {"threshold": 5, "within_hours": 2}),
    (AutoHideRuleType.keyword_filter, True, {"keywords": []}),
    (AutoHideRuleType.anonymous_spam, True, {"max_posts": 3, "within_minutes": 30}),
    (AutoHideRuleType.new_user_rate, True, {"max_posts": 5, "within_hours": 1, "account_age_days": 7}),
    (AutoHideRuleType.engagement_anomaly, True, {"same_day_account_reports": 3}),
]


def seed():
    db = SessionLocal()
    try:
        # Seed categories
        for name, slug in CATEGORIES:
            if not db.query(Category).filter_by(slug=slug).first():
                db.add(Category(name=name, slug=slug))

        # Seed badges
        for name, slug, description, icon in BADGES:
            if not db.query(Badge).filter_by(slug=slug).first():
                db.add(Badge(name=name, slug=slug, description=description, icon=icon))

        # Seed auto-hide rules
        for rule_type, is_enabled, config in AUTO_HIDE_RULES:
            if not db.query(AutoHideRule).filter_by(rule_type=rule_type).first():
                db.add(AutoHideRule(rule_type=rule_type, is_enabled=is_enabled, config=config))

        db.commit()
        print("‚úÖ Seed complete.")
    except Exception as e:
        db.rollback()
        print(f"‚ùå Seed failed: {e}")
        raise
    finally:
        db.close()


if __name__ == "__main__":
    seed()
```

---

## Step 4 ‚Äî Generate & Run Migration

```bash
# From inside the backend container OR with venv activated locally pointing to the DB
cd /home/nekwasar/yotop10/backend
source .venv/bin/activate

# Generate migration (Alembic auto-detects from models)
alembic revision --autogenerate -m "initial schema"

# Review the generated file in alembic/versions/ before running
# Make sure it lists all expected tables

# Run migration
alembic upgrade head
```

Or, when running inside Docker:

```bash
docker exec -it yotop10_backend alembic upgrade head
```

---

## Step 5 ‚Äî Run Seed Script

```bash
# Locally with venv
cd /home/nekwasar/yotop10/backend
source .venv/bin/activate
python -m app.utils.seed

# Or inside Docker
docker exec -it yotop10_backend python -m app.utils.seed
```

---

## Step 6 ‚Äî Verify Tables

```bash
docker exec -it yotop10_postgres psql -U yotop10_user -d yotop10

-- List all tables
\dt

-- Expected output (13 tables):
--  users
--  categories
--  posts
--  post_sources
--  pinned_posts
--  post_communities
--  list_items
--  communities
--  community_members
--  comments
--  reactions
--  follows
--  connections
--  badges
--  user_badges
--  reports
--  strikes
--  auto_hide_rules
--  ephemeral_threads
--  ephemeral_thread_participants
--  ephemeral_thread_messages

\q
```

---

## ‚úÖ M2 Completion Checklist

- [ ] All model files created in `backend/app/models/`
- [ ] `__init__.py` imports all models
- [ ] `alembic revision --autogenerate` generates all 21 tables
- [ ] `alembic upgrade head` runs successfully
- [ ] Seed script populates categories (16), badges (7), auto-hide rules (5)
- [ ] `\dt` in psql shows all expected tables
- [ ] No SQLAlchemy relationship errors in logs

---

## Notes for M3

- M3 (Authentication) will create `POST /auth/register`, `POST /auth/login`, `POST /auth/google`, `GET /auth/me`
- These endpoints insert into the `users` table ‚Äî all columns are now ready
- The `device_fingerprint` column on `users` is used for anonymous account spam prevention
- Do NOT create any users manually in the DB ‚Äî always go through the auth API in M3
